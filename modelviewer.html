<!DOCTYPE html>
<meta charset="utf-8">
<title>elite viewer</title>
<style>
body {
  margin: 0;
}
canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
#b {
  position: absolute;
  top: 10px;
  width: 100%;
  text-align: center;
  z-index: 2;
  color: white;
  font-family: monospace;
  font-size: 400%;
  mix-blend-mode: exclusion;
}
</style>
<canvas id="c"></canvas>
<div id="b"></div>
<script src="twgl-full.min.js"></script>
<script type="x-shader/x-vertex" id="vs">
uniform mat4 u_worldViewProjection;
uniform mat4 u_world;
attribute vec4 i_position;
attribute vec3 i_normal1;
attribute vec3 i_normal2;
varying vec3 v_normal1;
varying vec3 v_normal2;

void main() {
	gl_Position = u_worldViewProjection * i_position;
	v_normal1 = (u_world * vec4(i_normal1, 0)).xyz;
	v_normal2 = (u_world * vec4(i_normal2, 0)).xyz;
}
</script>
<script type="x-shader/x-fragment" id="fs">
precision mediump float;

varying vec3 v_normal1;
varying vec3 v_normal2;

void main() {
	if (v_normal1.z < 0.0 && v_normal2.z < 0.0)
		//gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
		discard;
	else
		gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );
}
</script>
<script src="shipdata.js"></script>
<script>
	"use strict";
	const v3 = twgl.v3;
	const m4 = twgl.m4;
	const gl = document.getElementById("c").getContext("webgl");

	function loadship(data) {
		const vertexes = data.vertexes;
		const edges = data.edges;
		const faces = data.faces;
		function betternormal(i) {
			if (i >= faces.length && i == 15)
				return [0, 0, 0];
			//return faces[i]; // uncomment to see original normals
			let e1, e2, n;
			for (const edge of edges) {
				if (edge[2] == i || edge[3] == i) {
					if (e1 === undefined) {
						e1 = edge;
					} else {
						e2 = edge;
						n = v3.cross(v3.subtract(vertexes[e1[0]], vertexes[e1[1]]), v3.subtract(vertexes[e2[0]], vertexes[e2[1]]));
						if (v3.length(n) != 0)
							break;
					}
				}
			}
			if (v3.dot(n, faces[i]) < 0)
				n = v3.negate(n);
			return v3.normalize(n);
		}
		const arrays = {
			i_position: [],
			i_normal1: [],
			i_normal2: []
		};
		for (const edge of edges) {
			const v1 = vertexes[edge[0]];
			const v2 = vertexes[edge[1]];
			const n1 = betternormal(edge[2]);
			const n2 = betternormal(edge[3]);
			arrays.i_position.push(v1[0], v1[1], -v1[2], v2[0], v2[1], -v2[2]);
			arrays.i_normal1.push(n1[0], n1[1], -n1[2], n1[0], n1[1], -n1[2]);
			arrays.i_normal2.push(n2[0], n2[1], -n2[2], n2[0], n2[1], -n2[2]);
		}
		return twgl.createBufferInfoFromArrays(gl, arrays);
	}

	const buffers = shipdata.map(loadship);
	let iship = 11;
	let allmode = false;
	function setship() {
		document.title = allmode ? 'ALL' : shipdata[iship].shipname;
		document.getElementById('b').innerText = allmode ? '' : shipdata[iship].shipname;
	}
	setship();

	const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);

	function matmul(...mats) {
		let i = mats.length;
		let m = m4.copy(mats[--i]);
		while (i > 0) {
			m4.multiply(mats[--i], m, m);
		}
		return m
	}
	function render(time) {
		time *= 0.002;
		twgl.resizeCanvasToDisplaySize(gl.canvas);
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight / (allmode ? 2 : 1);
		const w = 256;
		const zNear = 0.5;
		const zFar = w*2;
		const projection = aspect >= 1 ?
				m4.ortho(aspect*-w, aspect*w, -w, w, zNear, zFar) :
				m4.ortho(-w, w, -w/aspect, w/aspect, zNear, zFar);
		const eye = [0, 0, w];
		const target = [0, 0, 0];
		const up = [0, 1, 0];

		const camera = m4.lookAt(eye, target, up);
		const view = m4.inverse(camera);
		const world = matmul(m4.rotationZ(time*.3), m4.rotationY(time*.7), m4.rotationX(time));

		const uniforms = {
			u_worldViewProjection: matmul(projection, view, world),
			u_world: world,
		};

		gl.useProgram(programInfo.program);
		twgl.setUniforms(programInfo, uniforms);
		if (allmode) {
			const stepx = gl.canvas.width / 8;
			const stepy = gl.canvas.height / 4;
			for (let i = 0; i < shipdata.length; i++) {
				const x = i%8;
				const y = (i/8)^3;
				gl.viewport(x*stepx, y*stepy, stepx, stepy);
				twgl.setBuffersAndAttributes(gl, programInfo, buffers[i]);
				twgl.drawBufferInfo(gl, buffers[i], gl.LINES);
			}
		} else {
			twgl.setBuffersAndAttributes(gl, programInfo, buffers[iship]);
			twgl.drawBufferInfo(gl, buffers[iship], gl.LINES);
		}

		requestAnimationFrame(render);
	}
	requestAnimationFrame(render);

	document.body.addEventListener("keydown", (event) => {
		if (event.code == 'KeyJ') {
			iship = iship == shipdata.length-1 ? 0 : iship+1;
			setship();
		} else if (event.code == 'KeyK') {
			iship = iship == 0 ? shipdata.length-1 : iship-1;
			setship();
		} else if (event.code == 'KeyA') {
			allmode = !allmode;
			setship();
		}
	});
</script>
